<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Custom Jig Builder – Web</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    height: 100vh;
    overflow: hidden;
    display: flex;
  }
  #instructions {
    width: 240px;
    padding: 12px;
    background: #f4f4f4;
    border-right: 1px solid #ccc;
    box-sizing: border-box;
    overflow-y: auto;
  }
  #canvas-container {
    flex: 1;
    position: relative;
    background: #fff;
    overflow: hidden;
  }
  #controls {
    width: 260px;
    padding: 12px;
    background: #f9f9f9;
    border-left: 1px solid #ccc;
    box-sizing: border-box;
    overflow-y: auto;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    background: #ffffff;
  }
  label {
    display: block;
    margin: 6px 0 2px;
    font-size: 14px;
  }
  select, input, button {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 8px;
    padding: 6px;
    font-size: 14px;
  }
  #point-list {
    width: 100%;
    height: 170px;
    box-sizing: border-box;
  }
  .zoom-row {
    display: flex;
    gap: 6px;
  }
  .zoom-row button {
    flex: 1;
  }
  ul {
    padding-left: 18px;
  }
</style>
</head>
<body>
  <!-- Left: Instructions -->
  <div id="instructions">
    <h3>Instructions</h3>
    <ul>
      <li>Select enclosure size from dropdown.</li>
      <li>Click & drag on the canvas to pan.</li>
      <li>Use + / – to zoom or Fit to Screen.</li>
      <li>Add points by entering X/Y (inches) and choosing a face.</li>
      <li>Click a point in the list, edit the fields, then press <b>Update Point</b>.</li>
      <li>Deleting points re-alphabetizes labels automatically.</li>
      <li>Toggle Orientation rotates the top view (portrait ↔ landscape) and re-fits.</li>
    </ul>
  </div>

  <!-- Center: Canvas -->
  <div id="canvas-container">
    <canvas id="jigCanvas"></canvas>
  </div>

  <!-- Right: Controls -->
  <div id="controls">
    <label for="enclosure">Enclosure Size</label>
    <select id="enclosure">
      <option value="1590B">1590B (2.4" × 4.4" × 1.07")</option>
      <option value="1590BB">1590BB (3.7" × 4.7" × 1.33")</option>
      <option value="125B">125B (2.6" × 4.8" × 1.4")</option>
      <option value="Custom">Custom</option>
    </select>

    <button id="toggleOrientationBtn">Toggle Orientation</button>

    <label for="face">Face</label>
    <select id="face">
      <option>Top</option>
      <option>Front</option>
      <option>Left</option>
      <option>Right</option>
    </select>

    <label for="xInput">X (in)</label>
    <input type="number" id="xInput" step="0.01" />

    <label for="yInput">Y (in)</label>
    <input type="number" id="yInput" step="0.01" />

    <button id="addPointBtn">Add Point</button>
    <button id="updatePointBtn">Update Point</button>

    <label for="point-list">Points</label>
    <select id="point-list" size="10"></select>

    <button id="deletePointBtn">Delete Point</button>
    <button id="exportBtn">Export CSV</button>

    <div class="zoom-row">
      <button id="zoomInBtn">+</button>
      <button id="zoomOutBtn">−</button>
      <button id="fitBtn">Fit to Screen</button>
    </div>
  </div>

<script>
/**
 * Custom Jig Builder – Web (converted from your Python “GUI Beta Release 2”)
 * Features:
 *  - Orthographic Top/Front/Left/Right views
 *  - Portrait-by-default, Toggle Orientation
 *  - Pan (mouse drag), Zoom (+/-), Fit to Screen
 *  - Add/Update/Delete points w/ auto re-label (A,B,C…)
 *  - CSV export
 */

(function() {
  // -----------------------------
  // State
  // -----------------------------
  const presets = {
    "1590B":   { w: 2.4,  h: 4.4,  d: 1.07 },
    "1590BB":  { w: 3.7,  h: 4.7,  d: 1.33 },
    "125B":    { w: 2.6,  h: 4.8,  d: 1.4  }
  };

  let rectWidth  = 2.4;  // portrait-first
  let rectHeight = 4.4;
  let rectDepth  = 1.07;

  let orientationLandscape = false; // default portrait
  let scale = 80; // pixels per inch
  let offsetX = 0;
  let offsetY = 0;
  let isPanning = false;
  let panStart = { x: 0, y: 0 };
  let selectedIndex = null;
  let points = []; // { x, y, face, label }

  // view positions are computed each draw
  let viewCenters = {}; // {Top:[cx,cy], Front:[cx,cy], ...}

  // constants
  const GAP_PX = 60;     // fixed pixel gap between faces
  const LABEL_PAD = 60;  // top+bottom label space used in fit calculations
  const MARGIN_PX = 40;

  // -----------------------------
  // DOM
  // -----------------------------
  const canvas = document.getElementById('jigCanvas');
  const ctx = canvas.getContext('2d');

  const enclosureSel = document.getElementById('enclosure');
  const toggleOrientationBtn = document.getElementById('toggleOrientationBtn');

  const faceSel = document.getElementById('face');
  const xInput = document.getElementById('xInput');
  const yInput = document.getElementById('yInput');

  const addPointBtn = document.getElementById('addPointBtn');
  const updatePointBtn = document.getElementById('updatePointBtn');
  const deletePointBtn = document.getElementById('deletePointBtn');
  const exportBtn = document.getElementById('exportBtn');

  const pointList = document.getElementById('point-list');

  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const fitBtn = document.getElementById('fitBtn');

  // -----------------------------
  // Helpers
  // -----------------------------
  function relabelPoints() {
    const A = 'A'.charCodeAt(0);
    points.forEach((p, i) => {
      p.label = String.fromCharCode(A + (i % 26));
    });
  }

  function refreshPointList() {
    pointList.innerHTML = '';
    points.forEach((p, i) => {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${p.label} [${p.face}] (${p.x.toFixed(3)}, ${p.y.toFixed(3)})`;
      pointList.appendChild(opt);
    });
  }

  function updateSelectedFields() {
    const idx = pointList.selectedIndex;
    if (idx < 0 || idx >= points.length) {
      selectedIndex = null;
      return;
    }
    selectedIndex = idx;
    const pt = points[idx];
    faceSel.value = pt.face;
    xInput.value = pt.x.toFixed(3);
    yInput.value = pt.y.toFixed(3);
  }

  function setCanvasSizeToContainer() {
    const container = document.getElementById('canvas-container');
    const w = container.clientWidth;
    const h = container.clientHeight;
    canvas.width = w;
    canvas.height = h;
  }

  // -----------------------------
  // Orthographic Draw
  // -----------------------------
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Set center of content using offsets
    const cw = canvas.width;
    const ch = canvas.height;
    const centerX = cw / 2 + offsetX;
    const centerY = ch / 2 + offsetY;

    // Use oriented w/h for the "Top" face
    let w = rectWidth;
    let h = rectHeight;
    const d = rectDepth;

    if (orientationLandscape) {
      // swap width/height for the top face logic
      [w, h] = [h, w];
    }

    // compute center points of each orthographic rect in screen space
    viewCenters = {
      Top:   [ centerX, centerY ],
      Front: [ centerX, centerY - (h * scale) / 2 - GAP_PX - (d * scale) / 2 ],
      Left:  [ centerX - (w * scale) / 2 - GAP_PX - (d * scale) / 2, centerY ],
      Right: [ centerX + (w * scale) / 2 + GAP_PX + (d * scale) / 2, centerY ]
    };

    // Draw the four faces
    drawFace('Top',   w, h);
    drawFace('Front', w, d);
    drawFace('Left',  d, h);
    drawFace('Right', d, h);

    // draw points
    points.forEach(p => drawPoint(p));
  }

  function drawFace(face, fw, fh) {
    const [cx, cy] = viewCenters[face];
    const x0 = cx - fw * scale / 2;
    const y0 = cy - fh * scale / 2;
    const x1 = cx + fw * scale / 2;
    const y1 = cy + fh * scale / 2;

    // Rect
    ctx.fillStyle = '#e0e0e0';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.fillRect(x0, y0, (x1 - x0), (y1 - y0));
    ctx.strokeRect(x0, y0, (x1 - x0), (y1 - y0));

    // Face label above
    ctx.fillStyle = '#000';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${face} View`, (x0 + x1) / 2, y0 - 4);

    // Dimensions below
    ctx.font = '11px Arial';
    ctx.textBaseline = 'top';
    ctx.fillText(`${fw.toFixed(2)}" × ${fh.toFixed(2)}"`, (x0 + x1) / 2, y1 + 4);
  }

  function drawPoint(pt) {
    const [cx, cy] = viewCenters[pt.face];
    const px = cx + pt.x * scale;
    const py = cy - pt.y * scale;
    const r = 5;

    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.font = '12px Arial';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    ctx.fillText(pt.label, px + 8, py);
  }

  // -----------------------------
  // Fit to Screen
  // -----------------------------
  function fitToScreen() {
    setCanvasSizeToContainer();

    // Portrait-oriented top dims used in the bounding box calculation
    let w = rectWidth;
    let h = rectHeight;
    let d = rectDepth;

    if (orientationLandscape) {
      // top face swapped
      [w, h] = [h, w];
    }

    const cw = canvas.width;
    const ch = canvas.height;

    // The total orthographic "inch" bounding box is roughly:
    // width:  w + 2*d   (Top in middle, Left & Right each with depth)
    // height: h + d     (Top plus Front)
    // We'll add pixel margins and gap constants.
    const denomW = (w + 2 * d);
    const denomH = (h + d);

    // protect against 0
    const safeDenomW = Math.max(denomW, 1e-6);
    const safeDenomH = Math.max(denomH, 1e-6);

    const scaleX = (cw - 2 * MARGIN_PX - 2 * GAP_PX) / safeDenomW;
    const scaleY = (ch - 2 * MARGIN_PX - GAP_PX - LABEL_PAD) / safeDenomH;
    scale = Math.max(Math.min(scaleX, scaleY), 1e-6);

    // Reset offsets so content is centered
    offsetX = 0;
    offsetY = 0;

    draw();

    // Optionally, we can recenter based on what was drawn (canvas bounding box approach).
    // But since we compute based on center, we should already be centered.
  }

  // -----------------------------
  // CSV Export
  // -----------------------------
  function exportCSV() {
    let csv = 'Label,Face,X (in),Y (in)\\n';
    points.forEach(pt => {
      csv += `${pt.label},${pt.face},${pt.x.toFixed(4)},${pt.y.toFixed(4)}\\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'jig_points.csv';
    a.click();
    URL.revokeObjectURL(url);
  }

  // -----------------------------
  // UI Actions
  // -----------------------------
  function addPoint() {
    const x = parseFloat(xInput.value);
    const y = parseFloat(yInput.value);
    if (isNaN(x) || isNaN(y)) {
      alert('X and Y must be numbers.');
      return;
    }
    const face = faceSel.value;
    const label = String.fromCharCode('A'.charCodeAt(0) + (points.length % 26));
    points.push({ x, y, face, label });
    relabelPoints();
    refreshPointList();
    draw();
  }

  function updatePoint() {
    const idx = pointList.selectedIndex;
    if (idx < 0 || idx >= points.length) {
      alert('Please select a point to update.');
      return;
    }
    const x = parseFloat(xInput.value);
    const y = parseFloat(yInput.value);
    if (isNaN(x) || isNaN(y)) {
      alert('X and Y must be numbers.');
      return;
    }
    points[idx].x = x;
    points[idx].y = y;
    points[idx].face = faceSel.value;
    relabelPoints();
    refreshPointList();
    pointList.selectedIndex = idx;
    draw();
  }

  function deletePoint() {
    const idx = pointList.selectedIndex;
    if (idx < 0 || idx >= points.length) return;
    points.splice(idx, 1);
    relabelPoints();
    refreshPointList();
    draw();
  }

  function toggleOrientation() {
    orientationLandscape = !orientationLandscape;
    fitToScreen();
  }

  function changeEnclosure() {
    const val = enclosureSel.value;
    if (val === 'Custom') {
      const w = parseFloat(prompt('Enter width (in):', '2.4'));
      const h = parseFloat(prompt('Enter height (in):', '4.4'));
      const d = parseFloat(prompt('Enter depth (in):', '1.07'));
      if (isNaN(w) || isNaN(h) || isNaN(d)) {
        alert('Invalid dimensions');
        return;
      }
      rectWidth = w;
      rectHeight = h;
      rectDepth = d;
      orientationLandscape = false; // reset to portrait
      fitToScreen();
    } else {
      const dims = presets[val];
      if (dims) {
        rectWidth = dims.w;
        rectHeight = dims.h;
        rectDepth = dims.d;
        orientationLandscape = false; // default portrait each time
        fitToScreen();
      }
    }
  }

  function zoomIn() {
    scale *= 1.1;
    draw();
  }

  function zoomOut() {
    scale /= 1.1;
    if (scale < 1e-6) scale = 1e-6;
    draw();
  }

  // Pan
  function onMouseDown(e) {
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
  }
  function onMouseMove(e) {
    if (!isPanning) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    offsetX += dx;
    offsetY += dy;
    draw();
  }
  function onMouseUp() {
    isPanning = false;
  }

  // -----------------------------
  // Bind Events
  // -----------------------------
  enclosureSel.addEventListener('change', changeEnclosure);
  toggleOrientationBtn.addEventListener('click', toggleOrientation);

  addPointBtn.addEventListener('click', addPoint);
  updatePointBtn.addEventListener('click', updatePoint);
  deletePointBtn.addEventListener('click', deletePoint);
  exportBtn.addEventListener('click', exportCSV);

  pointList.addEventListener('change', updateSelectedFields);

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  fitBtn.addEventListener('click', fitToScreen);

  // Pan events on canvas
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('mouseleave', onMouseUp);

  // Re-fit on window resize (to keep everything centered)
  window.addEventListener('resize', () => {
    fitToScreen();
  });

  // -----------------------------
  // Init
  // -----------------------------
  function init() {
    setCanvasSizeToContainer();
    changeEnclosure(); // load default
    fitToScreen();
  }
  init();
})();
</script>
</body>
</html>
